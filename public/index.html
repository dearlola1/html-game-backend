<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>KENDRICK VS DRAKE</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap">
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('consent', 'default', {
            'ad_storage': 'denied',
            'analytics_storage': 'denied'
        });
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Tiny5', Arial, sans-serif;
            position: relative;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-overflow-scrolling: touch;
            touch-action: none;
        }

        #left-ad, #right-ad {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 160px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #left-ad {
            left: 0;
        }

        #right-ad {
            right: 0;
        }

        #ad-container {
            display: none;
        }

        @media (min-width: 768px) {
            #ad-container {
                display: flex;
            }
        }

        canvas {
            background-image: url('https://i.imgur.com/nFevFKm.png');
            background-size: cover;
            display: block;
            width: 430px;
            height: 932px;
        }

        #gameOver, #startScreen, #nameInput, #controls {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 100%;
            max-width: 430px;
        }

        #gameOver, #nameInput, #controls {
            display: none;
        }

        #gameOver .section {
            margin: 10px 0;
            padding: 20px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
        }

        #gameOver .highScoreSection {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            justify-content: space-around;
        }

        #gameOver button, #startScreen button, #nameInput button, #controls button {
            padding: 10px 20px;
            margin-top: 10px;
            font-size: 16px;
        }

        .character-select {
            margin: 10px;
            cursor: pointer;
        }

        #highScoreListDrake, #highScoreListKendrick {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 45%;
            text-align: center;
        }

        .sound-toggle, .controls-button {
            margin-top: 20px;
            cursor: pointer;
        }

        #consentBanner {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            text-align: center;
            z-index: 1000;
        }

        #consentBanner button {
            margin: 5px;
        }

        .highScoreSection div {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 10px;
        }

        .highScoreSection p {
            font-size: 20px;
            margin: 5px 0;
        }

        .total-score {
            font-size: 24px;
            font-weight: bold;
        }

        .highScoreSection ul li {
            margin-bottom: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 16px;
        }

        #kickStreamContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            display: none;
        }

        @media (min-width: 768px) {
            #kickStreamContainer {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="ad-container">
        <div id="left-ad">
            <ins class="adsbygoogle"
                style="display:block"
                data-ad-client="ca-pub-1329458568594916"
                data-ad-slot="5807899174"
                data-ad-format="auto"
                data-full-width-responsive="true"></ins>
        </div>
        <div id="right-ad">
            <ins class="adsbygoogle"
                style="display:block"
                data-ad-client="ca-pub-1329458568594916"
                data-ad-slot="5807899174"
                data-ad-format="auto"
                data-full-width-responsive="true"></ins>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="startScreen">
        <h1>Select Your Character</h1>
        <div>
            <button class="character-select" onclick="selectCharacter('drake')">Drake</button>
            <button class="character-select" onclick="selectCharacter('kendrick')">Kendrick</button>
        </div>
        <button class="sound-toggle" onclick="toggleSound()">Sound: <span id="soundStatus">On</span></button>
        <button class="controls-button" onclick="showControls()">Controls</button>
    </div>
    <div id="controls">
        <h1>Controls</h1>
        <h2>Mobile</h2>
        <p>Tap left side = Jump</p>
        <p>Tap right side = Shoot</p>
        <h2>Desktop</h2>
        <p>Spacebar = Jump</p>
        <p>'R' key = Shoot</p>
        <button onclick="hideControls()">Back</button>
    </div>
    <div id="nameInput">
        <h1>Enter Your Name</h1>
        <input type="text" id="playerName" placeholder="Your name">
        <button onclick="startGame()">Start Game</button>
    </div>
    <div id="gameOver">
        <div class="section">
            <h1 id="gameOverText">Game Over</h1>
            <p id="finalScore">Final Score: 0</p>
        </div>
        <div class="section highScoreSection">
            <div>
                <h2>DRAKE</h2>
                <p>Total Score</p>
                <p id="drakeScoreSum" class="total-score">0</p>
                <ul id="highScoreListDrake"></ul>
            </div>
            <div>
                <h2>KENDRICK</h2>
                <p>Total Score</p>
                <p id="kendrickScoreSum" class="total-score">0</p>
                <ul id="highScoreListKendrick"></ul>
            </div>
        </div>
        <button onclick="restartGame()">Restart</button>
    </div>
    <div id="consentBanner">
        <p>We use cookies to ensure you get the best experience on our website. <a href="https://kendrickvsdrake-afe300f0b023.herokuapp.com/policy.html" target="_blank">Learn more</a></p>
        <button id="grantConsent" onclick="acceptConsent()">Accept</button>
        <button onclick="declineConsent()">Decline</button>
    </div>
    <div id="kickStreamContainer">
        <iframe 
            src="https://player.kick.com/dearlola1?autoplay=true&muted=true" 
            height="180" 
            width="320" 
            frameborder="0" 
            scrolling="no" 
            allowfullscreen="true">
        </iframe>
    </div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1329458568594916" crossorigin="anonymous"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-B17MN4MS09', { 'send_page_view': false });

        function acceptConsent() {
            gtag('consent', 'update', {
                'ad_storage': 'granted',
                'analytics_storage': 'granted'
            });
            document.cookie = "consent=true; max-age=31536000; path=/";
            consentBanner.style.display = 'none';
            startScreen.style.display = 'block';
            document.getElementById('consentOverlay').style.display = 'none';
            loadGtagScript();
        }

        function declineConsent() {
            gtag('consent', 'update', {
                'ad_storage': 'denied',
                'analytics_storage': 'denied'
            });
            document.cookie = "consent=false; max-age=31536000; path=/";
            consentBanner.style.display = 'none';
            window.location.href = 'https://www.google.com';
        }

        function loadGtagScript() {
            var gtagScript = document.createElement('script');
            gtagScript.async = true;
            gtagScript.src = 'https://www.googletagmanager.com/gtag/js?id=G-B17MN4MS09';
            document.head.appendChild(gtagScript);
        }

        function checkConsent() {
            const consent = document.cookie.split('; ').find(row => row.startsWith('consent='));
            if (!consent) {
                consentBanner.style.display = 'block';
                document.getElementById('consentOverlay').style.display = 'block';
            } else {
                const consentValue = consent.split('=')[1];
                if (consentValue === 'true') {
                    consentBanner.style.display = 'none';
                    startScreen.style.display = 'block';
                    document.getElementById('consentOverlay').style.display = 'none';
                    loadGtagScript();
                } else {
                    consentBanner.style.display = 'block';
                    document.getElementById('consentOverlay').style.display = 'block';
                }
            }
        }

        window.onload = checkConsent;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverUI = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const finalScore = document.getElementById('finalScore');
        const highScoreListDrake = document.getElementById('highScoreListDrake');
        const highScoreListKendrick = document.getElementById('highScoreListKendrick');
        const drakeScoreSum = document.getElementById('drakeScoreSum');
        const kendrickScoreSum = document.getElementById('kendrickScoreSum');
        const nameInput = document.getElementById('nameInput');
        const playerNameInput = document.getElementById('playerName');
        const soundStatus = document.getElementById('soundStatus');
        const controlsScreen = document.getElementById('controls');
        const consentBanner = document.getElementById('consentBanner');

        let isSoundOn = true;

        const drakeImage = new Image();
        drakeImage.src = 'https://i.imgur.com/oNnc2WL.png';

        const kendrickImage = new Image();
        kendrickImage.src = 'https://i.imgur.com/8DLtz2J.png';

        const projectileImage = new Image();
        projectileImage.src = 'https://i.imgur.com/F24I2a9.png';

        const redBoxProjectileImage = new Image();
        redBoxProjectileImage.src = 'https://i.imgur.com/W6Ebd9d.png';

        const purpleBoxImage = new Image();
        purpleBoxImage.src = 'https://i.imgur.com/YIQ9XdR.png';

        const brownBoxImage = new Image();
        brownBoxImage.src = 'https://i.imgur.com/TJ9oMkH.png';

        const redBoxImage = new Image();
        redBoxImage.src = 'https://i.imgur.com/f9ZMzUp.png';

        const rockImage = new Image();
        rockImage.src = 'https://i.imgur.com/hZ7aWFu.png'; // Rock image URL

        const drakeHitSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/drake%20hit%20sound.wav');
        drakeHitSound.volume = 0.7; // Set volume to 80%

        const kendrickHitSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/kendrick%20hit%20sound.wav');
        kendrickHitSound.volume = 0.8; // Set volume to 80%

        const backgroundMusic = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/noit%20like%20us%20cheap.mp3');
        backgroundMusic.volume = 0.3; // Set volume to 50%
        backgroundMusic.loop = true;

        const purpleBoxSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/purple%20box%20sound.wav');
        purpleBoxSound.volume = 0.6; // Set volume to 60%

        const brownBoxSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/anita%20max.mp3');
        brownBoxSound.volume = 0.9; // Set volume to 60%

        const redBoxSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/red%20box%20sound.wav');
        redBoxSound.volume = 0.6; // Set volume to 60%

        const rockImpactSound = new Audio('https://raw.githubusercontent.com/dearlola1/html-game-backend/main/rock%20sound.mp3');
        rockImpactSound.volume = 0.8; // Set volume to 80%

        const wallImage1 = new Image();
        wallImage1.src = 'https://i.imgur.com/9sYPAtj.png';

        const wallImage2 = new Image();
        wallImage2.src = 'https://i.imgur.com/W8YPX4t.png';

        canvas.width = 430;
        canvas.height = 932;

        let player, npc, projectiles, npcProjectiles, boxes, walls, damageIndicators, rocks;
        let isCameraShaking = false;
        let cameraShakeDuration = 0;
        let gameLoopInterval, spawnBoxTimeout, npcShootInterval, wallAnimationInterval, playerIdleTimeout;
        let selectedPlayer;
        let lastTime = 0;
        let gameStartTime = 0;
        let playerScore = 0;
        let playerName = '';
        let currentWallImage = wallImage1;

        async function submitHighScore(playerName, score, character) {
            try {
                const response = await fetch('https://kendrickvsdrake-afe300f0b023.herokuapp.com/highscores', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer c922f825-4de5-4693-bdba-dd753c4e4a82' // API key
                    },
                    body: JSON.stringify({ player: playerName, score: score, character: character })
                });
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log('High score submitted:', data);
                return data;
            } catch (error) {
                console.error('Error submitting high score:', error);
            }
        }

        async function fetchHighScores() {
            try {
                const response = await fetch('https://kendrickvsdrake-afe300f0b023.herokuapp.com/highscores', {
                    headers: {
                        'Authorization': 'Bearer c922f825-4de5-4693-bdba-dd753c4e4a82' // API key
                    }
                });
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log('Fetched high scores:', data);
                return data;
            } catch (error) {
                console.error('Error fetching high scores:', error);
            }
        }

        async function updateHighScores() {
            const highScores = await fetchHighScores();
            let drakeScores = highScores.filter(score => score.character === 'drake');
            let kendrickScores = highScores.filter(score => score.character === 'kendrick');
            
            let drakeScoreSumValue = drakeScores.reduce((sum, score) => sum + score.score, 0);
            let kendrickScoreSumValue = kendrickScores.reduce((sum, score) => sum + score.score, 0);
            
            drakeScoreSum.textContent = `${drakeScoreSumValue}`;
            kendrickScoreSum.textContent = `${kendrickScoreSumValue}`;
            
            highScoreListDrake.innerHTML = '';
            highScoreListKendrick.innerHTML = '';
            
            drakeScores.forEach(score => {
                const li = document.createElement('li');
                const playerName = document.createElement('span');
                playerName.textContent = score.player;
                const playerScore = document.createElement('span');
                playerScore.textContent = score.score;
                li.appendChild(playerName);
                li.appendChild(playerScore);
                highScoreListDrake.appendChild(li);
            });
            
            kendrickScores.forEach(score => {
                const li = document.createElement('li');
                const playerName = document.createElement('span');
                playerName.textContent = score.player;
                const playerScore = document.createElement('span');
                playerScore.textContent = score.score;
                li.appendChild(playerName);
                li.appendChild(playerScore);
                highScoreListKendrick.appendChild(li);
            });
        }

        function toggleSound() {
            isSoundOn = !isSoundOn;
            soundStatus.textContent = isSoundOn ? 'On' : 'Off';
            if (isSoundOn) {
                backgroundMusic.play();
            } else {
                backgroundMusic.pause();
            }
        }

        function showControls() {
            startScreen.style.display = 'none';
            controlsScreen.style.display = 'block';
        }

        function hideControls() {
            controlsScreen.style.display = 'none';
            startScreen.style.display = 'block';
        }

        function selectCharacter(character) {
            selectedPlayer = character;
            startScreen.style.display = 'none';
            nameInput.style.display = 'block';
        }

        function startGame() {
            playerName = playerNameInput.value.trim();
            if (!playerName) {
                alert("Please enter your name");
                return;
            }
            nameInput.style.display = 'none';
            const npcCharacter = selectedPlayer === 'drake' ? 'kendrick' : 'drake';
            initGame(selectedPlayer, npcCharacter);
            requestFullscreen();
            gameStartTime = performance.now();
            if (isSoundOn) {
                backgroundMusic.play();
            }
            gameLoopInterval = requestAnimationFrame(gameLoop);
        }

        function requestFullscreen() {
            const element = document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            } else if (canvas.requestFullscreen) {
                canvas.requestFullscreen();
            } else if (canvas.webkitRequestFullscreen) {
                canvas.webkitRequestFullscreen();
            } else if (canvas.mozRequestFullScreen) {
                canvas.mozRequestFullScreen();
            } else if (canvas.msRequestFullscreen) {
                canvas.msRequestFullScreen();
            }
        }

        function initGame(playerCharacter, npcCharacter) {
            console.log("Initializing game with player:", playerCharacter, "and NPC:", npcCharacter);

            const playerImage = playerCharacter === 'drake' ? drakeImage : kendrickImage;
            const npcImage = npcCharacter === 'drake' ? drakeImage : kendrickImage;

            player = {
                x: 30,
                y: canvas.height - 120,
                width: 40,
                height: 80,
                image: playerImage,
                dy: 0,
                gravity: 0.4,
                jumpStrength: -9,
                onGround: true,
                hp: 222,
                canShoot: true,
                jumpCount: 0,
                maxJumps: 2,
                isFlashing: false,
                flashTimer: 0,
            };

            npc = {
                x: canvas.width - 70,
                y: canvas.height - 120,
                width: 40,
                height: 80,
                image: npcImage,
                dy: 0,
                gravity: 0.4,
                jumpStrength: -9,
                onGround: true,
                hp: 222,
                canShoot: true,
                jumpCount: 0,
                maxJumps: 2,
                isFlashing: false,
                flashTimer: 0,
            };

            projectiles = [];
            npcProjectiles = [];
            boxes = [];
            walls = [];
            damageIndicators = [];
            rocks = [];
            playerScore = 0;
            gameOverUI.style.display = 'none';

            clearInterval(npcShootInterval);
            clearInterval(wallAnimationInterval);

            npcShootInterval = setInterval(npcShoot, 600);
            wallAnimationInterval = setInterval(animateWalls, 300);

            const initialSpawnInterval = Math.floor(Math.random() * 8000) + 7000;
            clearTimeout(spawnBoxTimeout);
            spawnBoxTimeout = setTimeout(spawnBox, initialSpawnInterval);

            resetPlayerIdleTimeout();
        }

        function getRandomDamage() {
            return Math.floor(Math.random() * 5) + 2;
        }

        function getRockDamage() {
            return Math.floor(Math.random() * 26) + 25; // 25-50 damage
        }

        function getRandomHeal() {
            return Math.floor(Math.random() * 11) + 10;
        }

        function playSound(sound) {
            if (isSoundOn && sound) {
                sound.currentTime = 0;
                sound.play();
            }
        }

        function drawCharacter(character) {
            ctx.save();
            if (character.isFlashing) {
                ctx.globalAlpha = character.flashTimer % 2 === 0 ? 1 : 0.5;
                character.flashTimer++;
                if (character.flashTimer > 10) {
                    character.isFlashing = false;
                    character.flashTimer = 0;
                }
            }
            if (character === npc) {
                ctx.scale(-1, 1);
                ctx.drawImage(character.image, -character.x - character.width, character.y, character.width, character.height);
            } else {
                ctx.drawImage(character.image, character.x, character.y, character.width, character.height);
            }
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawPlatforms() {
            const platformHeight = 20;
            const platformWidth = canvas.width / 2 - 100;
            const platformY = canvas.height - 100;

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, platformY, platformWidth, platformHeight);
            ctx.fillRect(canvas.width - platformWidth, platformY, platformWidth, platformHeight);
        }

        function drawProjectiles(scaleFactor) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                projectile.x += projectile.dx * scaleFactor * 1.5;
                projectile.y += projectile.dy ? projectile.dy * scaleFactor * 1.5 : 0;

                if (projectile.image && projectile.image.complete && projectile.image.naturalWidth !== 0) {
                    ctx.drawImage(projectile.image, projectile.x, projectile.y, projectile.width, projectile.height);
                } else {
                    ctx.fillStyle = projectile.color;
                    ctx.fillRect(projectile.x, projectile.y, projectile.width, projectile.height);
                }

                if (npc && projectile.owner !== 'npc' && 
                    projectile.x + projectile.width >= npc.x &&
                    projectile.x <= npc.x + npc.width &&
                    projectile.y >= npc.y &&
                    projectile.y <= npc.y + npc.height) {
                    const damage = getRandomDamage();
                    npc.hp -= damage;
                    npc.isFlashing = true;
                    playerScore += damage;
                    damageIndicators.push({ x: npc.x + npc.width / 2, y: npc.y - 10, text: `-${damage}`, opacity: 1 });
                    projectiles.splice(i, 1);
                    playSound(npc.image === drakeImage ? drakeHitSound : kendrickHitSound);
                }

                for (let j = boxes.length - 1; j >= 0; j--) {
                    const box = boxes[j];
                    if (projectile.x + projectile.width >= box.x
                        && projectile.x <= box.x + box.width
                        && projectile.y >= box.y
                        && projectile.y <= box.y + box.height) {
                        const damage = getRandomDamage();
                        box.hp -= damage;
                        box.isFlashing = true;
                        playerScore += damage;
                        damageIndicators.push({ x: box.x + box.width / 2, y: box.y - 10, text: `-${damage}`, opacity: 1 });
                        if (box.hp <= 0) {
                            handleBoxDestruction(box, projectile.owner);
                            boxes.splice(j, 1);
                        }
                        projectiles.splice(i, 1);
                        break;
                    }
                }

                for (let j = walls.length - 1; j >= 0; j--) {
                    const wall = walls[j];
                    if (projectile.x + projectile.width >= wall.x
                        && projectile.x <= wall.x + wall.width
                        && projectile.y >= wall.y
                        && projectile.y <= wall.y + wall.height) {
                        const damage = getRandomDamage();
                        wall.hp -= damage;
                        wall.isFlashing = true;
                        playerScore += damage * 5;
                        damageIndicators.push({ x: wall.x + wall.width / 2, y: wall.y - 10, text: `-${damage}`, opacity: 1 });
                        if (wall.hp <= 0) {
                            walls.splice(j, 1);
                            playSound(purpleBoxSound);
                        }
                        projectiles.splice(i, 1);
                        break;
                    }
                }

                if (projectile.x > canvas.width || projectile.x < 0 || projectile.y > canvas.height || projectile.y < 0) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function drawNpcProjectiles(scaleFactor) {
            for (let i = npcProjectiles.length - 1; i >= 0; i--) {
                const projectile = npcProjectiles[i];
                projectile.x += projectile.dx * scaleFactor * 1.5;
                projectile.y += projectile.dy ? projectile.dy * scaleFactor * 1.5 : 0;

                if (projectile.image && projectile.image.complete && projectile.image.naturalWidth !== 0) {
                    ctx.drawImage(projectile.image, projectile.x, projectile.y, projectile.width, projectile.height);
                } else {
                    ctx.fillStyle = projectile.color;
                    ctx.fillRect(projectile.x, projectile.y, projectile.width, projectile.height);
                }

                if (player && projectile.x + projectile.width >= player.x
                    && projectile.x <= player.x + player.width
                    && projectile.y >= player.y
                    && projectile.y <= player.y + player.height) {
                    const damage = getRandomDamage();
                    player.hp -= damage;
                    player.isFlashing = true;
                    playerScore = Math.max(0, playerScore - damage);
                    triggerCameraShake();
                    damageIndicators.push({ x: player.x + player.width / 2, y: player.y - 10, text: `-${damage}`, opacity: 1 });
                    npcProjectiles.splice(i, 1);
                    playSound(player.image === drakeImage ? drakeHitSound : kendrickHitSound);
                }

                if (projectile.owner !== 'npc' && npc
                    && projectile.x + projectile.width >= npc.x
                    && projectile.x <= npc.x + npc.width
                    && projectile.y >= npc.y
                    && projectile.y <= npc.y + npc.height) {
                    const damage = getRandomDamage();
                    npc.hp -= damage;
                    npc.isFlashing = true;
                    damageIndicators.push({ x: npc.x + npc.width / 2, y: npc.y - 10, text: `-${damage}`, opacity: 1 });
                    npcProjectiles.splice(i, 1);
                }

                if (!projectile.fromRedBox) {
                    for (let j = boxes.length - 1; j >= 0; j--) {
                        const box = boxes[j];
                        if (projectile.x + projectile.width >= box.x
                            && projectile.x <= box.x + box.width
                            && projectile.y >= box.y
                            && projectile.y <= box.y + box.height) {
                            const damage = getRandomDamage();
                            box.hp -= damage;
                            box.isFlashing = true;
                            damageIndicators.push({ x: box.x + box.width / 2, y: box.y - 10, text: `-${damage}`, opacity: 1 });
                            if (box.hp <= 0) {
                                handleBoxDestruction(box, 'npc');
                                boxes.splice(j, 1);
                            }
                            npcProjectiles.splice(i, 1);
                            break;
                        }
                    }
                }

                for (let j = walls.length - 1; j >= 0; j--) {
                    const wall = walls[j];
                    if (projectile.x + projectile.width >= wall.x
                        && projectile.x <= wall.x + wall.width
                        && projectile.y >= wall.y
                        && projectile.y <= wall.y + wall.height) {
                        const damage = getRandomDamage();
                        wall.hp -= damage;
                        wall.isFlashing = true;
                        damageIndicators.push({ x: wall.x + wall.width / 2, y: wall.y - 10, text: `-${damage}`, opacity: 1 });
                        if (wall.hp <= 0) {
                            walls.splice(j, 1);
                        }
                        npcProjectiles.splice(i, 1);
                        break;
                    }
                }

                if (projectile.x > canvas.width || projectile.x < 0 || projectile.y > canvas.height || projectile.y < 0) {
                    npcProjectiles.splice(i, 1);
                }
            }
        }

        function drawBoxes(scaleFactor) {
            const oscillationAmplitude = canvas.width / 10;
            for (let i = boxes.length - 1; i >= 0; i--) {
                const box = boxes[i];
                box.y += box.dy * scaleFactor * 1.5;
                box.x = (canvas.width / 2) - (box.width / 2) + Math.sin(box.y / 20) * oscillationAmplitude;

                if (box.isFlashing) {
                    ctx.globalAlpha = box.flashTimer % 2 === 0 ? 1 : 0.5;
                    box.flashTimer++;
                    if (box.flashTimer > 10) {
                        box.isFlashing = false;
                        box.flashTimer = 0;
                    }
                }

                let boxImage;
                if (box.type === 'purple') {
                    boxImage = purpleBoxImage;
                } else if (box.type === 'brown') {
                    boxImage = brownBoxImage;
                } else if (box.type === 'red') {
                    boxImage = redBoxImage;
                }

                if (boxImage && boxImage.complete && boxImage.naturalWidth !== 0) {
                    ctx.drawImage(boxImage, box.x, box.y, box.width, box.height);
                } else {
                    ctx.fillStyle = box.color;
                    ctx.fillRect(box.x, box.y, box.width, box.height);
                }
                ctx.globalAlpha = 1;

                if (box.y > canvas.height) {
                    boxes.splice(i, 1);
                }
            }
        }

        function drawWalls() {
            for (let i = walls.length - 1; i >= 0; i--) {
                const wall = walls[i];
                if (wall.isFlashing) {
                    ctx.globalAlpha = wall.flashTimer % 2 === 0 ? 1 : 0.5;
                    wall.flashTimer++;
                    if (wall.flashTimer > 10) {
                        wall.isFlashing = false;
                        wall.flashTimer = 0;
                    }
                }

                ctx.drawImage(currentWallImage, wall.x, wall.y, wall.width, wall.height);

                if (wall.hp <= 0) {
                    walls.splice(i, 1);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawRocks(scaleFactor) {
    for (let i = rocks.length - 1; i >= 0; i--) {
        const rock = rocks[i];
        rock.x += rock.dx * scaleFactor;
        rock.y += rock.dy * scaleFactor;

        if (rock.isFlashing) {
            ctx.globalAlpha = rock.flashTimer % 2 === 0 ? 1 : 0.5;
            rock.flashTimer++;
            if (rock.flashTimer > 10) {
                rock.isFlashing = false;
                rock.flashTimer = 0;
                rocks.splice(i, 1); // Remove rock after flashing
            }
        }

        if (rockImage && rockImage.complete && rockImage.naturalWidth !== 0) {
            ctx.drawImage(rockImage, rock.x, rock.y, rock.width, rock.height);
        } else {
            ctx.fillStyle = rock.color;
            ctx.fillRect(rock.x, rock.y, rock.width, rock.height);
        }

        if (player && !rock.hasDealtDamage && rock.x + rock.width >= player.x
            && rock.x <= player.x + player.width
            && rock.y + rock.height >= player.y
            && rock.y <= player.y + player.height) {
            const damage = getRockDamage();
            player.hp -= damage;
            player.isFlashing = true;
            rock.isFlashing = true; // Trigger flashing before removal
            playSound(rockImpactSound);
            damageIndicators.push({ x: player.x + player.width / 2, y: player.y - 10, text: `-${damage}`, opacity: 1 });
            rock.hasDealtDamage = true; // Mark rock as having dealt damage
        }

        if (rock.x > canvas.width || rock.x < 0 || rock.y > canvas.height || rock.y < 0) {
            rocks.splice(i, 1);
        }
    }
}


        function updatePlayer(deltaTime) {
            if (player) {
                const scaleFactor = deltaTime / 16.67;
                player.dy += player.gravity * scaleFactor;
                player.y += player.dy * scaleFactor;

                if (player.y + player.height > canvas.height - 100) {
                    player.y = canvas.height - 100 - player.height;
                    player.dy = 0;
                    player.onGround = true;
                    player.jumpCount = 0;
                }
            }
        }

        function updateNpc(deltaTime) {
            if (npc) {
                const scaleFactor = deltaTime / 16.67;
                npc.dy += npc.gravity * scaleFactor;
                npc.y += npc.dy * scaleFactor;

                if (npc.y + npc.height > canvas.height - 100) {
                    npc.y = canvas.height - 100 - npc.height;
                    npc.dy = 0;
                    npc.onGround = true;
                    npc.jumpCount = 0;
                }

                projectiles.forEach(projectile => {
                    if (projectile.x > npc.x - 75 && projectile.x < npc.x && projectile.y >= npc.y && projectile.y <= npc.y + npc.height && npc.jumpCount < npc.maxJumps) {
                        if (Math.random() > 0.1) {
                            npc.dy = npc.jumpStrength;
                            npc.onGround = false;
                            npc.jumpCount++;

                            if (npc.jumpCount < npc.maxJumps && Math.random() > 0.7) {
                                setTimeout(() => {
                                    npc.dy = npc.jumpStrength;
                                    npc.jumpCount++;
                                }, 200);
                            }
                        }
                    }
                });
            }
        }

        function drawHP() {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            if (player) {
                ctx.strokeText(`HP: ${player.hp}`, 20, canvas.height - 50);
                ctx.fillText(`HP: ${player.hp}`, 20, canvas.height - 50);
            }
            if (npc) {
                ctx.strokeText(`HP: ${npc.hp}`, canvas.width - 80, canvas.height - 50);
                ctx.fillText(`HP: ${npc.hp}`, canvas.width - 80, canvas.height - 50);
            }
        }

        function drawDamageIndicators() {
            damageIndicators.forEach((indicator, index) => {
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.fillStyle = indicator.color || `rgba(255, 0, 0, ${indicator.opacity})`;
                ctx.font = '16px Arial';
                ctx.strokeText(indicator.text, indicator.x, indicator.y);
                ctx.fillText(indicator.text, indicator.x, indicator.y);
                indicator.y -= 1;
                indicator.opacity -= 0.02;
                if (indicator.opacity <= 0) {
                    damageIndicators.splice(index, 1);
                }
            });
        }

        function drawTimer() {
            const currentTime = performance.now();
            const elapsedTime = (currentTime - gameStartTime) / 1000;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.strokeText(`Time: ${elapsedTime.toFixed(1)}s`, canvas.width / 2 - 50, canvas.height - 50);
            ctx.fillText(`Time: ${elapsedTime.toFixed(1)}s`, canvas.width / 2 - 50, canvas.height - 50);
            return elapsedTime;
        }

        function drawScore() {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.strokeText(`Score: ${playerScore}`, 20, canvas.height - 20);
            ctx.fillText(`Score: ${playerScore}`, 20, canvas.height - 20);
        }

        function handleTap(event) {
            const tapX = event.touches[0].clientX;

            if (tapX < canvas.width / 2) {
                if (player && player.jumpCount < player.maxJumps) {
                    player.dy = player.jumpStrength;
                    player.onGround = false;
                    player.jumpCount++;
                    resetPlayerIdleTimeout();
                }
            } else {
                if (player && player.canShoot) {
                    projectiles.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2,
                        width: 12,
                        height: 12,
                        dx: 1.9 * 1.5,
                        owner: 'player',
                        image: projectileImage
                    });
                    player.canShoot = false;
                    setTimeout(() => {
                        if (player) {
                            player.canShoot = true;
                        }
                    }, 600);
                }
            }
        }

        function handleKeyDown(event) {
            if (event.code === 'Space') {
                if (player && player.jumpCount < player.maxJumps) {
                    player.dy = player.jumpStrength;
                    player.onGround = false;
                    player.jumpCount++;
                    resetPlayerIdleTimeout();
                }
            } else if (event.code === 'KeyR') {
                if (player && player.canShoot) {
                    projectiles.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2,
                        width: 12,
                        height: 12,
                        dx: 1.9 * 1.5,
                        owner: 'player',
                        image: projectileImage
                    });
                    player.canShoot = false;
                    setTimeout(() => {
                        if (player) {
                            player.canShoot = true;
                        }
                    }, 600);
                }
            }
        }

        function spawnBox() {
            console.log("Spawning box");
            const types = ['purple', 'brown', 'red'];
            const type = types[Math.floor(Math.random() * types.length)];
            const colorMap = {
                'purple': 'purple',
                'brown': 'brown',
                'red': 'red'
            };
            const box = {
                x: canvas.width / 2 - 75,
                y: 0,
                width: 20,
                height: 20,
                color: colorMap[type],
                dy: 0.4 * 1.5,
                hp: 3,
                isFlashing: false,
                flashTimer: 0,
                type: type,
            };
            boxes.push(box);

            const nextSpawnInterval = Math.floor(Math.random() * 8000) + 7000;
            clearTimeout(spawnBoxTimeout);
            spawnBoxTimeout = setTimeout(spawnBox, nextSpawnInterval);
        }

        function checkGameOver() {
            if ((player && player.hp <= 0) || (npc && npc.hp <= 0)) {
                const finalTime = drawTimer();
                const finalScoreValue = Math.round((playerScore * 10) - finalTime);
                finalScore.textContent = `Final Score: ${finalScoreValue}`;
                gameOverText.textContent = player && player.hp > 0 ? 'Victory' : 'Defeat';
                submitHighScore(playerName, finalScoreValue, selectedPlayer).then(() => {
                    updateHighScores().then(() => {
                        gameOverUI.style.display = 'block';
                    });
                });
                clearTimeout(spawnBoxTimeout);
                clearInterval(npcShootInterval);
                clearInterval(wallAnimationInterval);
                clearTimeout(playerIdleTimeout);
                cancelAnimationFrame(gameLoopInterval);
                if (player && player.hp <= 0) {
                    player = null;
                }
                if (npc && npc.hp <= 0) {
                    npc = null;
                }
                if (isSoundOn) {
                    backgroundMusic.pause();
                }
            }
        }

        function restartGame() {
            cancelAnimationFrame(gameLoopInterval);
            clearTimeout(spawnBoxTimeout);
            clearInterval(npcShootInterval);
            clearInterval(wallAnimationInterval);
            clearTimeout(playerIdleTimeout);
            gameStartTime = performance.now();
            initGame(selectedPlayer, selectedPlayer === 'drake' ? 'kendrick' : 'drake');
            if (isSoundOn) {
                backgroundMusic.play();
            }
            gameLoopInterval = requestAnimationFrame(gameLoop);
        }

        function triggerCameraShake() {
            isCameraShaking = true;
            cameraShakeDuration = 20;
        }

        function applyCameraShake() {
            if (isCameraShaking) {
                const shakeIntensity = 5;
                const offsetX = (Math.random() - 0.5) * shakeIntensity;
                const offsetY = (Math.random() - 0.5) * shakeIntensity;
                canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                cameraShakeDuration--;

                if (cameraShakeDuration <= 0) {
                    isCameraShaking = false;
                    canvas.style.transform = 'translate(0, 0)';
                }
            }
        }

        function handleBoxDestruction(box, owner) {
            console.log("Box destroyed:", box);
            let soundToPlay;

            if (box.type === 'purple') {
                soundToPlay = purpleBoxSound;
                const wall = {
                    x: box.x,
                    y: box.y,
                    width: 65,
                    height: 50,
                    hp: 30,
                    isFlashing: false,
                    flashTimer: 0,
                };
                walls.push(wall);
            } else if (box.type === 'brown') {
                soundToPlay = brownBoxSound;
                const healAmount = getRandomHeal();
                if (owner === 'player') {
                    player.hp = Math.min(player.hp + healAmount, 222);
                    damageIndicators.push({ x: player.x + player.width / 2, y: player.y - 10, text: `+${healAmount}`, opacity: 1, color: 'green' });
                } else if (owner === 'npc') {
                    npc.hp = Math.min(npc.hp + healAmount, 222);
                    damageIndicators.push({ x: npc.x + npc.width / 2, y: npc.y - 10, text: `+${healAmount}`, opacity: 1, color: 'green' });
                }
            } else if (box.type === 'red') {
                soundToPlay = redBoxSound;
                const numProjectiles = 12;
                const angleStep = (2 * Math.PI) / numProjectiles;
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = i * angleStep;
                    npcProjectiles.push({
                        x: box.x + box.width / 2,
                        y: box.y + box.height / 2,
                        width: 12,
                        height: 12,
                        dx: 1.5 * Math.cos(angle) * 1.5,
                        dy: 1.5 * Math.sin(angle) * 1.5,
                        fromRedBox: true,
                        image: redBoxProjectileImage
                    });
                }
            }

            playSound(soundToPlay);
        }

        function npcShoot() {
            if (npc && npc.canShoot && Math.random() > 0.2) {
                npcProjectiles.push({
                    x: npc.x,
                    y: npc.y + npc.height / 2,
                    width: 12,
                    height: 12,
                    dx: -1.9 * 1.5,
                    owner: 'npc',
                    image: projectileImage
                });
                npc.canShoot = false;
                setTimeout(() => {
                    if (npc) {
                        npc.canShoot = true;
                    }
                }, 600);
            }
        }

        function animateWalls() {
            currentWallImage = currentWallImage === wallImage1 ? wallImage2 : wallImage1;
        }

        function triggerFallingRock() {
            rocks.push({
                x: canvas.width - 30,
                y: canvas.height / 2.3,
                width: 50,
                height: 40,
                dx: -3.0,
                dy: 3.0,
                owner: 'falling',
                image: rockImage,
                isFlashing: false,
                flashTimer: 0,
            });
            resetPlayerIdleTimeout();
        }

        function resetPlayerIdleTimeout() {
            clearTimeout(playerIdleTimeout);
            playerIdleTimeout = setTimeout(triggerFallingRock, 9000);
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const scaleFactor = deltaTime / 16.67;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawPlatforms();
            if (player) drawCharacter(player);
            if (npc) drawCharacter(npc);
            drawProjectiles(scaleFactor);
            drawNpcProjectiles(scaleFactor);
            drawBoxes(scaleFactor);
            drawWalls();
            drawRocks(scaleFactor);
            updatePlayer(deltaTime);
            updateNpc(deltaTime);
            drawHP();
            drawDamageIndicators();
            if (!gameOverUI.style.display || gameOverUI.style.display === 'none') {
                drawTimer();
                drawScore();
            }
            checkGameOver();
            applyCameraShake();

            gameLoopInterval = requestAnimationFrame(gameLoop);
        }

        window.onload = checkConsent;
        canvas.addEventListener('touchstart', handleTap);
        window.addEventListener('keydown', handleKeyDown);
    </script>
    <div id="consentOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 999;"></div>
</body>
</html>
